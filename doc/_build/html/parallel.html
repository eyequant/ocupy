<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Parallel &mdash; res.analysis 0.01 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.01',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="res.analysis 0.01 documentation" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="index.html">res.analysis 0.01 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-res.analysis.parallel">
<span id="parallel"></span><h1>Parallel<a class="headerlink" href="#module-res.analysis.parallel" title="Permalink to this headline">¶</a></h1>
<p>This module implements functionality to parallelize massively
parallel tasks. A massively parallel task consists of repeatedly
carrying out the same computation. Each individual computation
might depend on different parameters but there exist no dpendencies
between different tasks.</p>
<p>This module provides three different classes to achieve massive
prallelization: <a class="reference internal" href="#taskstore"><em>TaskStore</em></a>, <a class="reference internal" href="#taskmanager"><em>TaskManager</em></a>  and <a class="reference internal" href="#worker"><em>Worker</em></a></p>
<dl class="docutils">
<dt>Each module characterizes one of three steps that is necessary:</dt>
<dd><ol class="first last arabic simple">
<li>Provide a task description and an ordering of tasks</li>
<li>Make tasks available for parallel processing</li>
<li>Carry out a task</li>
</ol>
</dd>
</dl>
<p>These classes work together to process tasks in a parallel fashion.
The TaskStore provides an interface that allows to iterate over
individual task descriptions. The TaskManager is a XMLRPC server
which provides task descriptions for workers. A Worker is a XMLRPC
client that connects to a task manager and retrieves a task description,
executes the task and sends back the results.</p>
<div class="section" id="organizing-tasks-for-distribution">
<h2>Organizing tasks for distribution<a class="headerlink" href="#organizing-tasks-for-distribution" title="Permalink to this headline">¶</a></h2>
<p id="taskstore">Preparing your own tasks for parallel computation starts with providing a
custom TaskStore object. A task store organizes how a complete task can be
divided into smaller tasks. Let&#8217;s consider an example. Say we want to compute
how well a single  subject can be predicted by some other random subject. In
this case, a task might be the calculation of one prediction score. The entire task
is to calculate scores for predicting each subject with each other subject.
If we have 48 subjects, we have 48*47 individual tasks.</p>
<p>A single task is usually described by a dictionary that has as keys the name
of a parameter and as value the value of a parameter:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">task</span><span class="p">)</span> <span class="ow">in</span> <span class="n">task_store</span><span class="p">:</span> <span class="k">print</span> <span class="n">task</span>
<span class="p">{</span><span class="s">&#39;index&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;predicted_sub&#39;</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span><span class="s">&#39;predicting_sub&#39;</span><span class="p">:</span><span class="mi">10</span><span class="p">}</span>
</pre></div>
</div>
<p>Internally a task store deals only with a linear index into all possible tasks.
To provide a custom task store you have implement a class that inherits from parallel.TaskStore
and implements four functions:</p>
<blockquote>
<div><ol class="arabic simple">
<li>get(index, *params)   -   A function that returns a task description</li>
<li>sub2ind(*params)    -   A function that maps parameters to a linear index</li>
<li>ind2sub(index)        -   A function that maps a linear index to a set of parameters</li>
<li>update_results(task_index, task_results)     -   A function that takes the results for a task and saves &#8216;em / organizes &#8216;em.</li>
</ol>
</div></blockquote>
<p>An example implementation is given below:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">ISTaskStore</span><span class="p">(</span><span class="n">parallel</span><span class="o">.</span><span class="n">TaskStore</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">partitions</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span><span class="n">ind</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">filename</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">parallel</span><span class="o">.</span><span class="n">TaskStore</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">partitions</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_tasks</span> <span class="o">=</span> <span class="mi">48</span> <span class="o">*</span> <span class="mi">47</span> <span class="c"># This is required!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">48</span><span class="p">,</span><span class="mi">47</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span><span class="n">predicting</span><span class="p">,</span> <span class="n">predicted</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub2ind</span><span class="p">(</span><span class="n">predicting</span><span class="p">,</span> <span class="n">predicted</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="s">&#39;index&#39;</span><span class="p">:</span><span class="n">index</span><span class="p">,</span> <span class="s">&#39;predicting&#39;</span><span class="p">:</span><span class="n">predicting</span><span class="p">,</span> <span class="s">&#39;predicted&#39;</span><span class="p">:</span><span class="n">predicted</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">sub2ind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicting</span><span class="p">,</span> <span class="n">predicted</span><span class="p">):</span>
        <span class="c"># parallel.sub2ind maps 1 &lt;- (1,1), 2 &lt;- (1,2) ... 47 &lt;- (1,47), 48 &lt;- (2,1) etc.</span>
        <span class="k">return</span> <span class="n">parallel</span><span class="o">.</span><span class="n">sub2ind</span><span class="p">((</span><span class="n">predicting</span><span class="p">,</span> <span class="n">predicted</span><span class="p">),</span> <span class="p">(</span><span class="mi">48</span><span class="p">,</span><span class="mi">47</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">ind2sub</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="c"># parallel.sub2ind maps 1 -&gt; (1,1), 2 -&gt; (1,2), ... 47 -&gt; (1,47), 48 -&gt; (2,1) etc.</span>
        <span class="k">return</span> <span class="n">parallel</span><span class="o">.</span><span class="n">ind2sub</span><span class="p">(</span><span class="n">index</span><span class="p">,(</span><span class="mi">48</span><span class="p">,</span><span class="mi">47</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">update_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task_index</span><span class="p">,</span> <span class="n">task_results</span><span class="p">):</span>
       <span class="k">for</span> <span class="n">cur_res</span> <span class="ow">in</span> <span class="n">task_results</span><span class="p">:</span>
            <span class="c"># Find position for this result in result matrix</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">cur_res</span><span class="p">[</span><span class="s">&#39;index&#39;</span><span class="p">]</span>
            <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ind2sub</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="n">params</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur_res</span><span class="p">[</span><span class="s">&#39;result&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>Let&#8217;s see what this does:</p>
<div class="highlight-python"><pre>from res.analysis import parallel
ts = ISTaskStore()
ts.get(None, 1,1)
   {'index': 0, 'predicted': 1, 'predicting': 1}
ts.get(None, 2,1)
    {'index': 47, 'predicted': 1, 'predicting': 2}</pre>
</div>
<p>The task store provides an iterator interface that allows to iterate over all
tasks in the task store.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">ts</span><span class="p">:</span> <span class="k">print</span> <span class="n">task</span>
<span class="c"># Will list all tasks</span>
</pre></div>
</div>
<p>An important property of a task store is that it can <em>partition</em> itself into
smaller groups of subtask. Often computing the result of a single task comes
with significant overhead, thus each worker receives a group of tasks (which
is represented again by a TaskStore object) and then iterates over all tasks
in the store. Every task store object can be instantiated with a list of valid
indices, such that iterating through the store iterates only through these tasks.:</p>
<div class="highlight-python"><pre>ts = ISTaskStore(indices=[1,2,3])
for task in ts: print task
   (1, {'index': 1, 'predicting': 1, 'predicted': 2})
   (2, {'index': 2, 'predicting': 1, 'predicted': 3})
   (3, {'index': 3, 'predicting': 1, 'predicted': 4})</pre>
</div>
<p>Another important function of a task store is <em>update_results(self, task_id, task_description)</em>
It is called by the server whenever the results for a partition were returned by
a worker. This function has to be implemented by you and gives you a
chance to put the results back into a form that you can interpret and <em>save</em>!</p>
<p>One more thing: TaskStores and Workers usually come in pairs. To avoid that you
use a worker that was not intended to be used with a specific TaskStore a task store needs
to be able to identify itself. It therefore needs to have a field .ident which
needs to be set by you.</p>
</div>
<div class="section" id="making-tasks-available-for-processing">
<h2>Making tasks available for processing<a class="headerlink" href="#making-tasks-available-for-processing" title="Permalink to this headline">¶</a></h2>
<p id="taskmanager">When a task store object is available we can start a server that waits
for workers to pick up tasks. To do so, we create an instance of
TaskManager and run it:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">twisted.internet</span> <span class="kn">import</span> <span class="n">reactor</span>
<span class="kn">from</span> <span class="nn">twisted.web</span> <span class="kn">import</span> <span class="n">xmlrpc</span><span class="p">,</span> <span class="n">server</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">parallel</span><span class="o">.</span><span class="n">TaskManager</span><span class="p">(</span><span class="n">task_store</span><span class="p">)</span>
<span class="n">reactor</span><span class="o">.</span><span class="n">listenTCP</span><span class="p">(</span><span class="mi">7080</span><span class="p">,</span> <span class="n">server</span><span class="o">.</span><span class="n">Site</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
<span class="n">reactor</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>It is best to do this in a screen and then detach the screen.
You can check that it is running by firing up ipython and typing:</p>
<div class="highlight-python"><pre>import xmlrpclib
s = xmlrpclib.Server('http://localhost:7080')
print s.status()
    100 Jobs are still wating for execution
    0 Jobs are being processed
    0 Jobs are done</pre>
</div>
<p>Remember that the server iterates over partitions (and the default number
of partitions is 100), thus for the server one job is one partition of the tasks.
You can query the server with the server object:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">k</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">get_task</span><span class="p">()</span>
<span class="n">s</span><span class="o">.</span><span class="n">reschedule</span><span class="p">()</span> <span class="c"># Reschedule all tasks that are being processed</span>
</pre></div>
</div>
</div>
<div class="section" id="getting-things-done">
<h2>Getting things done<a class="headerlink" href="#getting-things-done" title="Permalink to this headline">¶</a></h2>
<p id="worker">When everything is in place (task store available, server started) it is time to
actually do the work. For this we create instances of parallel.Worker.</p>
<p>Each worker instance will then connect to the server, call server.get_task(), iterate over
the returned task_store and call <em>compute(self, index, task_description)</em> for each task.
It collects the output for each compute call and returns it to the server and then quits.</p>
<p>Often the worker needs access to data that needs to be loaded beforehand. Thus, the
constructor of parallel. Worker calls <em>setup(self)</em> before starting the computation.
This gives you a chance to organize the necessary data.</p>
<p>The only tasks left to you are implementing a setup and a compute method. Here is an example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">ISWorker</span><span class="p">(</span><span class="n">parallel</span><span class="o">.</span><span class="n">Worker</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="s">&#39;/net/space/users/nwilming/&#39;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">fixmat</span><span class="o">.</span><span class="n">FixmatFactory</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span><span class="s">&#39;fixmat.mat&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[(</span><span class="n">data</span><span class="o">.</span><span class="n">on_image</span> <span class="o">==</span> <span class="bp">True</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ismember</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">fix</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">17</span><span class="p">)))]</span>

    <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">task_description</span><span class="p">):</span>
        <span class="n">predicted</span>  <span class="o">=</span> <span class="n">task_description</span><span class="p">[</span><span class="s">&#39;predicted&#39;</span><span class="p">]</span>
        <span class="n">predicting</span> <span class="o">=</span> <span class="n">task_description</span><span class="p">[</span><span class="s">&#39;predicting&#39;</span><span class="p">]</span>
        <span class="n">rescale</span> <span class="o">=</span> <span class="mf">0.5</span>
        <span class="p">(</span><span class="n">auc</span><span class="p">,</span> <span class="n">nss</span><span class="p">,</span> <span class="n">kl</span><span class="p">)</span> <span class="o">=</span> <span class="n">roc</span><span class="o">.</span><span class="n">intersubject_scores</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                <span class="n">predicting</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">65</span><span class="p">),</span>
                                <span class="n">predicted</span><span class="p">,</span> <span class="n">controls</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span> <span class="n">scale_factor</span> <span class="o">=</span> <span class="n">rescale</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;index&#39;</span><span class="p">:</span> <span class="n">index</span><span class="p">,</span>
                <span class="s">&#39;auc&#39;</span> <span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">auc</span><span class="p">),</span>
                <span class="s">&#39;nss&#39;</span> <span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">nss</span><span class="p">),</span>
                <span class="s">&#39;kl&#39;</span> <span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">kl</span><span class="p">)}</span>
        <span class="n">result</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">task_description</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
<p>To start a worker, instantiate it and call it&#8217;s run() function. The rest happens
automatically.</p>
<p>The real power of this approach lies in using the GridEngine to start as many workers as
there are task partitions. The GridEngine then starts as many workers as is possible.</p>
</div>
<div class="section" id="reference">
<h2>Reference<a class="headerlink" href="#reference" title="Permalink to this headline">¶</a></h2>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Parallel</a><ul>
<li><a class="reference internal" href="#organizing-tasks-for-distribution">Organizing tasks for distribution</a></li>
<li><a class="reference internal" href="#making-tasks-available-for-processing">Making tasks available for processing</a></li>
<li><a class="reference internal" href="#getting-things-done">Getting things done</a></li>
<li><a class="reference internal" href="#reference">Reference</a></li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/parallel.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="index.html">res.analysis 0.01 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2010, WhiteMatter Labs GmbH.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2b1.
    </div>
  </body>
</html>